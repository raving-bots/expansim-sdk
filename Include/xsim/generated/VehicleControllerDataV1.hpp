// Copyright Raving Bots 2018-2020
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file SDK-LICENSE or copy at https://www.boost.org/LICENSE_1_0.txt)

// <auto-generated>
//     WARNING: This file has been generated automatically. Do not edit manually, changes will be lost.
// </auto-generated>

#pragma once

#include <xsim/types.hpp>

#include "AngleV1.hpp"
#include "ForceFeedbackV1.hpp"
#include "SatForceV1.hpp"

namespace xsim
{
	struct VehicleControllerDataV1 final
	{
		constexpr VehicleControllerDataV1() = default;
		constexpr VehicleControllerDataV1(const VehicleControllerDataV1&) = default;
		constexpr VehicleControllerDataV1(VehicleControllerDataV1&&) = default;
		~VehicleControllerDataV1() = default;
		constexpr VehicleControllerDataV1& operator=(const VehicleControllerDataV1&) = default;
		constexpr VehicleControllerDataV1& operator=(VehicleControllerDataV1&&) = default;

		int32_t m_PlayerId{};
		::xsim::Boolean<uint8_t> m_DebugAiControl{};
		::xsim::Boolean<uint8_t> m_DebugForceFeedback{};
		::xsim::SignalBipolar m_SteeringWheelInput{};
		::xsim::AngleV1 m_SteeringWheelAngle{};
		::xsim::SatForceV1 m_SatForce{};
		::xsim::ForceFeedbackV1 m_ForceFeedback{};
		::xsim::Boolean<uint8_t> m_EngineStarter{};
		::xsim::SignalUnipolar m_Throttle{};
		::xsim::SignalUnipolar m_Brake{};
		::xsim::SignalUnipolar m_Clutch{};
		::xsim::SignalUnipolar m_HandBrake{};
		::xsim::Boolean<uint8_t> m_HandBrakeToggle{};
		::xsim::Boolean<uint8_t> m_UseGearTarget{};
		int32_t m_GearTarget{};
		int32_t m_GearChange{};
		::xsim::Boolean<uint8_t> m_GearboxSplitRangeUpper{};
		::xsim::Boolean<uint8_t> m_GearboxSplitGearUpper{};
		::xsim::Boolean<uint8_t> m_GearboxSemiAutoChange{};
		::xsim::Boolean<uint8_t> m_NeutralPivot{};
		int32_t m_RetarderChange{};
		::xsim::Boolean<uint8_t> m_DriveFrontChange{};
		::xsim::Boolean<uint8_t> m_DriveRearChange{};
		::xsim::Boolean<uint8_t> m_DiffLockFrontChange{};
		::xsim::Boolean<uint8_t> m_DiffLockInterChange{};
		::xsim::Boolean<uint8_t> m_DiffLockRearChange{};
		::xsim::Boolean<uint8_t> m_Horn{};
		::xsim::Boolean<uint8_t> m_HeadlampsChange{};
		::xsim::Boolean<uint8_t> m_HeadlampsBeamChange{};
		::xsim::Boolean<uint8_t> m_TurnLeftChange{};
		::xsim::Boolean<uint8_t> m_TurnRightChange{};
		::xsim::Boolean<uint8_t> m_HazardWarningChange{};
		::xsim::Boolean<uint8_t> m_EmergencyLightsChange{};
		::xsim::Boolean<uint8_t> m_EmergencySirenChange{};
		::xsim::Boolean<uint8_t> m_SystemAbaChange{};
		::xsim::Boolean<uint8_t> m_SystemAbsChange{};
		::xsim::Boolean<uint8_t> m_SystemAsrChange{};
		::xsim::Boolean<uint8_t> m_SystemEscChange{};
		::xsim::Boolean<uint8_t> m_PneumaticDoorChange{};
		::xsim::Vector2F m_PrimaryActuator{};
		::xsim::Vector2F m_SecondaryActuator{};
	};
}

static_assert(
	std::is_standard_layout<::xsim::VehicleControllerDataV1>::value,
	"SDK bug: TypeStruct VehicleControllerDataV1 not standard layout"
);

namespace fmt
{
	template <typename Char>
	struct formatter<::xsim::VehicleControllerDataV1, Char>
	{
		template <typename ParseContext>
		constexpr auto parse(ParseContext& ctx)
		{
			return ctx.begin();
		}

		template <typename FormatContext>
		auto format(const ::xsim::VehicleControllerDataV1& value, FormatContext& ctx)
		{
			return format_to(ctx.out(), XSIM_FMT_LITERAL("VehicleControllerDataV1"));
		}
	};
}
